\hypertarget{classfcal_1_1parser_1_1Parser}{}\section{fcal\+:\+:parser\+:\+:Parser Class Reference}
\label{classfcal_1_1parser_1_1Parser}\index{fcal\+::parser\+::\+Parser@{fcal\+::parser\+::\+Parser}}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classfcal_1_1parser_1_1Parser_aab2e272d7a2e630fa248a61aa3b22653}{$\sim$\+Parser} (void)\hypertarget{classfcal_1_1parser_1_1Parser_aab2e272d7a2e630fa248a61aa3b22653}{}\label{classfcal_1_1parser_1_1Parser_aab2e272d7a2e630fa248a61aa3b22653}

\begin{DoxyCompactList}\small\item\em \hyperlink{classfcal_1_1parser_1_1Parser}{Parser} deconstructor function. \end{DoxyCompactList}\item 
\hyperlink{classfcal_1_1parser_1_1ParseResult}{Parse\+Result} \hyperlink{classfcal_1_1parser_1_1Parser_a57428b932759f7a6d5d65ff6e83c3ed1}{Parse} (const char $\ast$text)\hypertarget{classfcal_1_1parser_1_1Parser_a57428b932759f7a6d5d65ff6e83c3ed1}{}\label{classfcal_1_1parser_1_1Parser_a57428b932759f7a6d5d65ff6e83c3ed1}

\begin{DoxyCompactList}\small\item\em Parse constructor function. \end{DoxyCompactList}\item 
\hyperlink{classfcal_1_1parser_1_1ParseResult}{Parse\+Result} \hyperlink{classfcal_1_1parser_1_1Parser_a43de3cc3ab812c746520188acad91b3d}{Parse\+Program} ()\hypertarget{classfcal_1_1parser_1_1Parser_a43de3cc3ab812c746520188acad91b3d}{}\label{classfcal_1_1parser_1_1Parser_a43de3cc3ab812c746520188acad91b3d}

\begin{DoxyCompactList}\small\item\em Parse\+Program creates the first node in the A\+ST, the Program Node. \end{DoxyCompactList}\item 
\hyperlink{classfcal_1_1parser_1_1ParseResult}{Parse\+Result} \hyperlink{classfcal_1_1parser_1_1Parser_a5f3775636ba12362f72e039561336557}{parse\+\_\+decl} ()
\item 
\hyperlink{classfcal_1_1parser_1_1ParseResult}{Parse\+Result} \hyperlink{classfcal_1_1parser_1_1Parser_aa62545007028e5272d9643c876a9822c}{parse\+\_\+standard\+\_\+decl} ()
\item 
\hyperlink{classfcal_1_1parser_1_1ParseResult}{Parse\+Result} \hyperlink{classfcal_1_1parser_1_1Parser_aa4fe3c8652e6b19863d561f7bd5d6184}{parse\+\_\+matrix\+\_\+decl} ()
\item 
\hyperlink{classfcal_1_1parser_1_1ParseResult}{Parse\+Result} \hyperlink{classfcal_1_1parser_1_1Parser_a4380df554ab7d5e34118f766270de432}{parse\+\_\+stmts} ()
\item 
\hyperlink{classfcal_1_1parser_1_1ParseResult}{Parse\+Result} \hyperlink{classfcal_1_1parser_1_1Parser_aa5a86ad0157bcd6f1c65a849ea5acafa}{parse\+\_\+stmt} ()
\item 
\hyperlink{classfcal_1_1parser_1_1ParseResult}{Parse\+Result} {\bfseries parse\+\_\+expr} (int rbp)\hypertarget{classfcal_1_1parser_1_1Parser_ae3ef50b5c351bd8d899be70b00977246}{}\label{classfcal_1_1parser_1_1Parser_ae3ef50b5c351bd8d899be70b00977246}

\item 
\hyperlink{classfcal_1_1parser_1_1ParseResult}{Parse\+Result} \hyperlink{classfcal_1_1parser_1_1Parser_a90f9e6e5bb7b0bb8f6165653081d9df3}{parse\+\_\+true\+\_\+kwd} ()
\item 
\hyperlink{classfcal_1_1parser_1_1ParseResult}{Parse\+Result} \hyperlink{classfcal_1_1parser_1_1Parser_a3118c7b669131067232a17de629549f6}{parse\+\_\+false\+\_\+kwd} ()
\item 
\hyperlink{classfcal_1_1parser_1_1ParseResult}{Parse\+Result} \hyperlink{classfcal_1_1parser_1_1Parser_a8acdff8197580eb1d945072ff679306d}{parse\+\_\+int\+\_\+const} ()
\item 
\hyperlink{classfcal_1_1parser_1_1ParseResult}{Parse\+Result} \hyperlink{classfcal_1_1parser_1_1Parser_a86beefd5cab1bacded97977bd0785f31}{parse\+\_\+float\+\_\+const} ()
\item 
\hyperlink{classfcal_1_1parser_1_1ParseResult}{Parse\+Result} \hyperlink{classfcal_1_1parser_1_1Parser_ac87c57a45735cf4a811b4517e62001d5}{parse\+\_\+string\+\_\+const} ()
\item 
\hyperlink{classfcal_1_1parser_1_1ParseResult}{Parse\+Result} {\bfseries parse\+\_\+char\+\_\+const} ()\hypertarget{classfcal_1_1parser_1_1Parser_ab8d667fc04e0cbea885b0def177a5b8c}{}\label{classfcal_1_1parser_1_1Parser_ab8d667fc04e0cbea885b0def177a5b8c}

\item 
\hyperlink{classfcal_1_1parser_1_1ParseResult}{Parse\+Result} \hyperlink{classfcal_1_1parser_1_1Parser_a42a63ca82e8a3401f9e1e5cf6942a17f}{parse\+\_\+variable\+\_\+name} ()
\item 
\hyperlink{classfcal_1_1parser_1_1ParseResult}{Parse\+Result} \hyperlink{classfcal_1_1parser_1_1Parser_a230ffe70c18b3dad6d10ddec36a35e2f}{parse\+\_\+nested\+\_\+expr} ()
\item 
\hyperlink{classfcal_1_1parser_1_1ParseResult}{Parse\+Result} \hyperlink{classfcal_1_1parser_1_1Parser_a2349961f9d8868b8089ea13ae9e98fb4}{parse\+\_\+not\+\_\+expr} ()
\item 
\hyperlink{classfcal_1_1parser_1_1ParseResult}{Parse\+Result} \hyperlink{classfcal_1_1parser_1_1Parser_afe47685e472719748894c8991853de30}{parse\+\_\+let\+\_\+expr} ()
\item 
\hyperlink{classfcal_1_1parser_1_1ParseResult}{Parse\+Result} \hyperlink{classfcal_1_1parser_1_1Parser_a4f0fe50e12d5693818bf37fbbdda6ad4}{parse\+\_\+if\+\_\+expr} ()
\item 
\hyperlink{classfcal_1_1parser_1_1ParseResult}{Parse\+Result} \hyperlink{classfcal_1_1parser_1_1Parser_a491fe4bd93f17982da6242143a418521}{parse\+\_\+addition} (\hyperlink{classfcal_1_1parser_1_1ParseResult}{Parse\+Result} left)
\item 
\hyperlink{classfcal_1_1parser_1_1ParseResult}{Parse\+Result} \hyperlink{classfcal_1_1parser_1_1Parser_af32daaf2d2a1b933cc3de2c940ee48c4}{parse\+\_\+multiplication} (\hyperlink{classfcal_1_1parser_1_1ParseResult}{Parse\+Result} left)
\item 
\hyperlink{classfcal_1_1parser_1_1ParseResult}{Parse\+Result} \hyperlink{classfcal_1_1parser_1_1Parser_a2a7d7d74a714bb560017b15e745cf36e}{parse\+\_\+subtraction} (\hyperlink{classfcal_1_1parser_1_1ParseResult}{Parse\+Result} left)
\item 
\hyperlink{classfcal_1_1parser_1_1ParseResult}{Parse\+Result} \hyperlink{classfcal_1_1parser_1_1Parser_a244da88d6e0fffb16df81a2d63599d12}{parse\+\_\+division} (\hyperlink{classfcal_1_1parser_1_1ParseResult}{Parse\+Result} left)
\item 
\hyperlink{classfcal_1_1parser_1_1ParseResult}{Parse\+Result} \hyperlink{classfcal_1_1parser_1_1Parser_a6de383f3ce806fdeb0a627b323cadc82}{parse\+\_\+relational\+\_\+expr} (\hyperlink{classfcal_1_1parser_1_1ParseResult}{Parse\+Result} left)
\item 
void {\bfseries match} (const scanner\+::\+Token\+Type \&tt)\hypertarget{classfcal_1_1parser_1_1Parser_a83087c1451996a4446a945e230a5a34c}{}\label{classfcal_1_1parser_1_1Parser_a83087c1451996a4446a945e230a5a34c}

\item 
bool {\bfseries attempt\+\_\+match} (const scanner\+::\+Token\+Type \&tt)\hypertarget{classfcal_1_1parser_1_1Parser_a995d89e662161c0e968da921ffc38153}{}\label{classfcal_1_1parser_1_1Parser_a995d89e662161c0e968da921ffc38153}

\item 
bool {\bfseries next\+\_\+is} (const scanner\+::\+Token\+Type \&tt)\hypertarget{classfcal_1_1parser_1_1Parser_a98962efd8ee05a0a39c7500a365f00f4}{}\label{classfcal_1_1parser_1_1Parser_a98962efd8ee05a0a39c7500a365f00f4}

\item 
void {\bfseries next\+\_\+token} (void)\hypertarget{classfcal_1_1parser_1_1Parser_a4d5068c9590fc1a6e370fc86a0057899}{}\label{classfcal_1_1parser_1_1Parser_a4d5068c9590fc1a6e370fc86a0057899}

\end{DoxyCompactItemize}


\subsection{Member Function Documentation}
\index{fcal\+::parser\+::\+Parser@{fcal\+::parser\+::\+Parser}!parse\+\_\+addition@{parse\+\_\+addition}}
\index{parse\+\_\+addition@{parse\+\_\+addition}!fcal\+::parser\+::\+Parser@{fcal\+::parser\+::\+Parser}}
\subsubsection[{\texorpdfstring{parse\+\_\+addition(\+Parse\+Result left)}{parse_addition(ParseResult left)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Parse\+Result} fcal\+::parser\+::\+Parser\+::parse\+\_\+addition (
\begin{DoxyParamCaption}
\item[{{\bf Parse\+Result}}]{pr\+Left}
\end{DoxyParamCaption}
)}\hypertarget{classfcal_1_1parser_1_1Parser_a491fe4bd93f17982da6242143a418521}{}\label{classfcal_1_1parser_1_1Parser_a491fe4bd93f17982da6242143a418521}
parse\+\_\+addition will generate a Binary\+Op with parameters expr, \char`\"{}+\char`\"{}, and expr2 \index{fcal\+::parser\+::\+Parser@{fcal\+::parser\+::\+Parser}!parse\+\_\+decl@{parse\+\_\+decl}}
\index{parse\+\_\+decl@{parse\+\_\+decl}!fcal\+::parser\+::\+Parser@{fcal\+::parser\+::\+Parser}}
\subsubsection[{\texorpdfstring{parse\+\_\+decl()}{parse_decl()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Parse\+Result} fcal\+::parser\+::\+Parser\+::parse\+\_\+decl (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classfcal_1_1parser_1_1Parser_a5f3775636ba12362f72e039561336557}{}\label{classfcal_1_1parser_1_1Parser_a5f3775636ba12362f72e039561336557}
parse\+\_\+decl will categorize what type of declaration using the current Token types to either parse\+\_\+matrix\+\_\+decl or parse\+\_\+standard\+\_\+decl \index{fcal\+::parser\+::\+Parser@{fcal\+::parser\+::\+Parser}!parse\+\_\+division@{parse\+\_\+division}}
\index{parse\+\_\+division@{parse\+\_\+division}!fcal\+::parser\+::\+Parser@{fcal\+::parser\+::\+Parser}}
\subsubsection[{\texorpdfstring{parse\+\_\+division(\+Parse\+Result left)}{parse_division(ParseResult left)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Parse\+Result} fcal\+::parser\+::\+Parser\+::parse\+\_\+division (
\begin{DoxyParamCaption}
\item[{{\bf Parse\+Result}}]{pr\+Left}
\end{DoxyParamCaption}
)}\hypertarget{classfcal_1_1parser_1_1Parser_a244da88d6e0fffb16df81a2d63599d12}{}\label{classfcal_1_1parser_1_1Parser_a244da88d6e0fffb16df81a2d63599d12}
parse\+\_\+division will generate a Binary\+Op with parameters expr, \char`\"{}/\char`\"{}, and expr2 \index{fcal\+::parser\+::\+Parser@{fcal\+::parser\+::\+Parser}!parse\+\_\+false\+\_\+kwd@{parse\+\_\+false\+\_\+kwd}}
\index{parse\+\_\+false\+\_\+kwd@{parse\+\_\+false\+\_\+kwd}!fcal\+::parser\+::\+Parser@{fcal\+::parser\+::\+Parser}}
\subsubsection[{\texorpdfstring{parse\+\_\+false\+\_\+kwd()}{parse_false_kwd()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Parse\+Result} fcal\+::parser\+::\+Parser\+::parse\+\_\+false\+\_\+kwd (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classfcal_1_1parser_1_1Parser_a3118c7b669131067232a17de629549f6}{}\label{classfcal_1_1parser_1_1Parser_a3118c7b669131067232a17de629549f6}
parser\+\_\+false\+\_\+kwd idenitifies the current node\textquotesingle{}s Token type and if it is k\+False\+Kwd then it generates a Bool\+False subclass \index{fcal\+::parser\+::\+Parser@{fcal\+::parser\+::\+Parser}!parse\+\_\+float\+\_\+const@{parse\+\_\+float\+\_\+const}}
\index{parse\+\_\+float\+\_\+const@{parse\+\_\+float\+\_\+const}!fcal\+::parser\+::\+Parser@{fcal\+::parser\+::\+Parser}}
\subsubsection[{\texorpdfstring{parse\+\_\+float\+\_\+const()}{parse_float_const()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Parse\+Result} fcal\+::parser\+::\+Parser\+::parse\+\_\+float\+\_\+const (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classfcal_1_1parser_1_1Parser_a86beefd5cab1bacded97977bd0785f31}{}\label{classfcal_1_1parser_1_1Parser_a86beefd5cab1bacded97977bd0785f31}
parse\+\_\+float\+\_\+const identifies the current node\textquotesingle{}s Token type and if it is k\+Float\+Const then it generates a Type\+Const subclass and passes in a \char`\"{}float\char`\"{} lexeme with it \index{fcal\+::parser\+::\+Parser@{fcal\+::parser\+::\+Parser}!parse\+\_\+if\+\_\+expr@{parse\+\_\+if\+\_\+expr}}
\index{parse\+\_\+if\+\_\+expr@{parse\+\_\+if\+\_\+expr}!fcal\+::parser\+::\+Parser@{fcal\+::parser\+::\+Parser}}
\subsubsection[{\texorpdfstring{parse\+\_\+if\+\_\+expr()}{parse_if_expr()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Parse\+Result} fcal\+::parser\+::\+Parser\+::parse\+\_\+if\+\_\+expr (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classfcal_1_1parser_1_1Parser_a4f0fe50e12d5693818bf37fbbdda6ad4}{}\label{classfcal_1_1parser_1_1Parser_a4f0fe50e12d5693818bf37fbbdda6ad4}
parse\+\_\+if\+\_\+expr will generate an If\+Expr subclass with parameters expr, expr2, and expr3 \index{fcal\+::parser\+::\+Parser@{fcal\+::parser\+::\+Parser}!parse\+\_\+int\+\_\+const@{parse\+\_\+int\+\_\+const}}
\index{parse\+\_\+int\+\_\+const@{parse\+\_\+int\+\_\+const}!fcal\+::parser\+::\+Parser@{fcal\+::parser\+::\+Parser}}
\subsubsection[{\texorpdfstring{parse\+\_\+int\+\_\+const()}{parse_int_const()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Parse\+Result} fcal\+::parser\+::\+Parser\+::parse\+\_\+int\+\_\+const (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classfcal_1_1parser_1_1Parser_a8acdff8197580eb1d945072ff679306d}{}\label{classfcal_1_1parser_1_1Parser_a8acdff8197580eb1d945072ff679306d}
parse\+\_\+int\+\_\+const identifies the current node\textquotesingle{}s Token type and if it is k\+Int\+Const then it generates a Type\+Const subclass and passes in a \char`\"{}int\char`\"{} lexeme with it \index{fcal\+::parser\+::\+Parser@{fcal\+::parser\+::\+Parser}!parse\+\_\+let\+\_\+expr@{parse\+\_\+let\+\_\+expr}}
\index{parse\+\_\+let\+\_\+expr@{parse\+\_\+let\+\_\+expr}!fcal\+::parser\+::\+Parser@{fcal\+::parser\+::\+Parser}}
\subsubsection[{\texorpdfstring{parse\+\_\+let\+\_\+expr()}{parse_let_expr()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Parse\+Result} fcal\+::parser\+::\+Parser\+::parse\+\_\+let\+\_\+expr (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classfcal_1_1parser_1_1Parser_afe47685e472719748894c8991853de30}{}\label{classfcal_1_1parser_1_1Parser_afe47685e472719748894c8991853de30}
parse\+\_\+let\+\_\+expr will generate a Let\+Expr with parameters stmts and expr \index{fcal\+::parser\+::\+Parser@{fcal\+::parser\+::\+Parser}!parse\+\_\+matrix\+\_\+decl@{parse\+\_\+matrix\+\_\+decl}}
\index{parse\+\_\+matrix\+\_\+decl@{parse\+\_\+matrix\+\_\+decl}!fcal\+::parser\+::\+Parser@{fcal\+::parser\+::\+Parser}}
\subsubsection[{\texorpdfstring{parse\+\_\+matrix\+\_\+decl()}{parse_matrix_decl()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Parse\+Result} fcal\+::parser\+::\+Parser\+::parse\+\_\+matrix\+\_\+decl (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classfcal_1_1parser_1_1Parser_aa4fe3c8652e6b19863d561f7bd5d6184}{}\label{classfcal_1_1parser_1_1Parser_aa4fe3c8652e6b19863d561f7bd5d6184}
parse\+\_\+matrix\+\_\+decl parses a matrix declaration. If the second token is a left square bracker then it will parse according to the Matrix\+Long\+Decl, but there is not left square bracket then it will parse according to the regular Matrix\+Decl \index{fcal\+::parser\+::\+Parser@{fcal\+::parser\+::\+Parser}!parse\+\_\+multiplication@{parse\+\_\+multiplication}}
\index{parse\+\_\+multiplication@{parse\+\_\+multiplication}!fcal\+::parser\+::\+Parser@{fcal\+::parser\+::\+Parser}}
\subsubsection[{\texorpdfstring{parse\+\_\+multiplication(\+Parse\+Result left)}{parse_multiplication(ParseResult left)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Parse\+Result} fcal\+::parser\+::\+Parser\+::parse\+\_\+multiplication (
\begin{DoxyParamCaption}
\item[{{\bf Parse\+Result}}]{pr\+Left}
\end{DoxyParamCaption}
)}\hypertarget{classfcal_1_1parser_1_1Parser_af32daaf2d2a1b933cc3de2c940ee48c4}{}\label{classfcal_1_1parser_1_1Parser_af32daaf2d2a1b933cc3de2c940ee48c4}
parse\+\_\+multiplication will generate a Binary\+Op with parameters expr, \char`\"{}$\ast$\char`\"{}, and expr2 \index{fcal\+::parser\+::\+Parser@{fcal\+::parser\+::\+Parser}!parse\+\_\+nested\+\_\+expr@{parse\+\_\+nested\+\_\+expr}}
\index{parse\+\_\+nested\+\_\+expr@{parse\+\_\+nested\+\_\+expr}!fcal\+::parser\+::\+Parser@{fcal\+::parser\+::\+Parser}}
\subsubsection[{\texorpdfstring{parse\+\_\+nested\+\_\+expr()}{parse_nested_expr()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Parse\+Result} fcal\+::parser\+::\+Parser\+::parse\+\_\+nested\+\_\+expr (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classfcal_1_1parser_1_1Parser_a230ffe70c18b3dad6d10ddec36a35e2f}{}\label{classfcal_1_1parser_1_1Parser_a230ffe70c18b3dad6d10ddec36a35e2f}
parse\+\_\+nested\+\_\+expr will generate a Paren\+Expr subclass with parameter expr \index{fcal\+::parser\+::\+Parser@{fcal\+::parser\+::\+Parser}!parse\+\_\+not\+\_\+expr@{parse\+\_\+not\+\_\+expr}}
\index{parse\+\_\+not\+\_\+expr@{parse\+\_\+not\+\_\+expr}!fcal\+::parser\+::\+Parser@{fcal\+::parser\+::\+Parser}}
\subsubsection[{\texorpdfstring{parse\+\_\+not\+\_\+expr()}{parse_not_expr()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Parse\+Result} fcal\+::parser\+::\+Parser\+::parse\+\_\+not\+\_\+expr (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classfcal_1_1parser_1_1Parser_a2349961f9d8868b8089ea13ae9e98fb4}{}\label{classfcal_1_1parser_1_1Parser_a2349961f9d8868b8089ea13ae9e98fb4}
parse\+\_\+not\+\_\+expr will generate a Not\+Expr with parameter expr \index{fcal\+::parser\+::\+Parser@{fcal\+::parser\+::\+Parser}!parse\+\_\+relational\+\_\+expr@{parse\+\_\+relational\+\_\+expr}}
\index{parse\+\_\+relational\+\_\+expr@{parse\+\_\+relational\+\_\+expr}!fcal\+::parser\+::\+Parser@{fcal\+::parser\+::\+Parser}}
\subsubsection[{\texorpdfstring{parse\+\_\+relational\+\_\+expr(\+Parse\+Result left)}{parse_relational_expr(ParseResult left)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Parse\+Result} fcal\+::parser\+::\+Parser\+::parse\+\_\+relational\+\_\+expr (
\begin{DoxyParamCaption}
\item[{{\bf Parse\+Result}}]{pr\+Left}
\end{DoxyParamCaption}
)}\hypertarget{classfcal_1_1parser_1_1Parser_a6de383f3ce806fdeb0a627b323cadc82}{}\label{classfcal_1_1parser_1_1Parser_a6de383f3ce806fdeb0a627b323cadc82}
parse\+\_\+relational\+\_\+expr will generate a Binary\+Op with expr, whichever relational expression, and expr2 \index{fcal\+::parser\+::\+Parser@{fcal\+::parser\+::\+Parser}!parse\+\_\+standard\+\_\+decl@{parse\+\_\+standard\+\_\+decl}}
\index{parse\+\_\+standard\+\_\+decl@{parse\+\_\+standard\+\_\+decl}!fcal\+::parser\+::\+Parser@{fcal\+::parser\+::\+Parser}}
\subsubsection[{\texorpdfstring{parse\+\_\+standard\+\_\+decl()}{parse_standard_decl()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Parse\+Result} fcal\+::parser\+::\+Parser\+::parse\+\_\+standard\+\_\+decl (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classfcal_1_1parser_1_1Parser_aa62545007028e5272d9643c876a9822c}{}\label{classfcal_1_1parser_1_1Parser_aa62545007028e5272d9643c876a9822c}
parse\+\_\+standard\+\_\+decl parses a type declaration. The decl\+\_\+type will be passed to the general Type\+Decl subclass and the decl\+\_\+type will be placed in front of the var\+Name ensuring correct parsing \index{fcal\+::parser\+::\+Parser@{fcal\+::parser\+::\+Parser}!parse\+\_\+stmt@{parse\+\_\+stmt}}
\index{parse\+\_\+stmt@{parse\+\_\+stmt}!fcal\+::parser\+::\+Parser@{fcal\+::parser\+::\+Parser}}
\subsubsection[{\texorpdfstring{parse\+\_\+stmt()}{parse_stmt()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Parse\+Result} fcal\+::parser\+::\+Parser\+::parse\+\_\+stmt (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classfcal_1_1parser_1_1Parser_aa5a86ad0157bcd6f1c65a849ea5acafa}{}\label{classfcal_1_1parser_1_1Parser_aa5a86ad0157bcd6f1c65a849ea5acafa}
parse\+\_\+stmt will categorize the type of statement by identifying the keyword and will create the according subclass for it. If the current token is a keyword associated with declarations; k\+Int\+Kwd, k\+Float\+Kwd, etc. it will create a Stmt\+Decl subclass. If the current token is the keyword k\+Left\+Curly then a Block\+Stmt subclass will be created If the current token is the keyword k\+If\+Kwd then a If\+Stmt subclass will be created, but if there is a token after that is k\+Else\+Kwd then the subclass If\+Else\+Stmt will created instead If the current token is the keyword k\+Variable\+Name and the next token is of type k\+Left\+Square then a Assign\+Long\+Stmt subclass will be created, but if then tokens are just k\+Variable\+Name and k\+Assign then an Assign\+Stmt will be created If the current token is the keyword k\+Print\+Kwd then a Print\+Stmt will be created If the current token is the keyword k\+Repeat\+Kwd then a Repeat\+Stmt will be created If the current token is the keyword k\+While\+Kwd then a While\+Stmt will be created If the current token is the keyword k\+Semi\+Colon then an End\+Stmt will be created If there is current token then throw an error message \index{fcal\+::parser\+::\+Parser@{fcal\+::parser\+::\+Parser}!parse\+\_\+stmts@{parse\+\_\+stmts}}
\index{parse\+\_\+stmts@{parse\+\_\+stmts}!fcal\+::parser\+::\+Parser@{fcal\+::parser\+::\+Parser}}
\subsubsection[{\texorpdfstring{parse\+\_\+stmts()}{parse_stmts()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Parse\+Result} fcal\+::parser\+::\+Parser\+::parse\+\_\+stmts (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classfcal_1_1parser_1_1Parser_a4380df554ab7d5e34118f766270de432}{}\label{classfcal_1_1parser_1_1Parser_a4380df554ab7d5e34118f766270de432}
parse\+\_\+stmts will parse Empty\+Stmts if it is the last Node of the A\+ST, but if the next Node in the A\+ST is neither a k\+Right\+Curly or a k\+In\+Kwd then it will continue parsing with Seq\+Stmts \index{fcal\+::parser\+::\+Parser@{fcal\+::parser\+::\+Parser}!parse\+\_\+string\+\_\+const@{parse\+\_\+string\+\_\+const}}
\index{parse\+\_\+string\+\_\+const@{parse\+\_\+string\+\_\+const}!fcal\+::parser\+::\+Parser@{fcal\+::parser\+::\+Parser}}
\subsubsection[{\texorpdfstring{parse\+\_\+string\+\_\+const()}{parse_string_const()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Parse\+Result} fcal\+::parser\+::\+Parser\+::parse\+\_\+string\+\_\+const (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classfcal_1_1parser_1_1Parser_ac87c57a45735cf4a811b4517e62001d5}{}\label{classfcal_1_1parser_1_1Parser_ac87c57a45735cf4a811b4517e62001d5}
parse\+\_\+string\+\_\+const identifies the current node\textquotesingle{}s Token type and if it is k\+String\+Const then it generates a Type\+Const subclass and passes in a \char`\"{}string\char`\"{} lexeme with it \index{fcal\+::parser\+::\+Parser@{fcal\+::parser\+::\+Parser}!parse\+\_\+subtraction@{parse\+\_\+subtraction}}
\index{parse\+\_\+subtraction@{parse\+\_\+subtraction}!fcal\+::parser\+::\+Parser@{fcal\+::parser\+::\+Parser}}
\subsubsection[{\texorpdfstring{parse\+\_\+subtraction(\+Parse\+Result left)}{parse_subtraction(ParseResult left)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Parse\+Result} fcal\+::parser\+::\+Parser\+::parse\+\_\+subtraction (
\begin{DoxyParamCaption}
\item[{{\bf Parse\+Result}}]{pr\+Left}
\end{DoxyParamCaption}
)}\hypertarget{classfcal_1_1parser_1_1Parser_a2a7d7d74a714bb560017b15e745cf36e}{}\label{classfcal_1_1parser_1_1Parser_a2a7d7d74a714bb560017b15e745cf36e}
parse\+\_\+subtraction will generate a Binary\+Op with parameters expr, \char`\"{}-\/\char`\"{}, and expr2 \index{fcal\+::parser\+::\+Parser@{fcal\+::parser\+::\+Parser}!parse\+\_\+true\+\_\+kwd@{parse\+\_\+true\+\_\+kwd}}
\index{parse\+\_\+true\+\_\+kwd@{parse\+\_\+true\+\_\+kwd}!fcal\+::parser\+::\+Parser@{fcal\+::parser\+::\+Parser}}
\subsubsection[{\texorpdfstring{parse\+\_\+true\+\_\+kwd()}{parse_true_kwd()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Parse\+Result} fcal\+::parser\+::\+Parser\+::parse\+\_\+true\+\_\+kwd (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classfcal_1_1parser_1_1Parser_a90f9e6e5bb7b0bb8f6165653081d9df3}{}\label{classfcal_1_1parser_1_1Parser_a90f9e6e5bb7b0bb8f6165653081d9df3}
parse\+\_\+true\+\_\+kwd identifies the current node\textquotesingle{}s Token type and if it is k\+True\+Kwd then it generates a Bool\+True subclass \index{fcal\+::parser\+::\+Parser@{fcal\+::parser\+::\+Parser}!parse\+\_\+variable\+\_\+name@{parse\+\_\+variable\+\_\+name}}
\index{parse\+\_\+variable\+\_\+name@{parse\+\_\+variable\+\_\+name}!fcal\+::parser\+::\+Parser@{fcal\+::parser\+::\+Parser}}
\subsubsection[{\texorpdfstring{parse\+\_\+variable\+\_\+name()}{parse_variable_name()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Parse\+Result} fcal\+::parser\+::\+Parser\+::parse\+\_\+variable\+\_\+name (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classfcal_1_1parser_1_1Parser_a42a63ca82e8a3401f9e1e5cf6942a17f}{}\label{classfcal_1_1parser_1_1Parser_a42a63ca82e8a3401f9e1e5cf6942a17f}
parse\+\_\+variable\+\_\+name identifies the current token\textquotesingle{}s type and creates a subclass according to it If the current token is the keyword k\+Left\+Square then a Matrix\+Ref subclass will be created If the current token is the keyword k\+Left\+Paren then a Nested\+Or\+Func\+Call will be created Else if the current token matches none of these then it creates a Var\+Name subclass 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
include/parser.\+h\item 
src/parser.\+cc\end{DoxyCompactItemize}
